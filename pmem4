BEGIN   % THIS IS ALL THE TOP-LEVEL GOODIES PLUS INFERENCE %
 
SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!ANAPHLISTNEW,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LAST_ANDTHEN,
	?!OUTPUT,?!LAST_OUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG, REACTTO, ERRNAME,
	STYPE, STOPIC, TRACE_MEM, ENDE,

	INPUTQUES,SSENT,DO_SPELL,NEXT_CHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOC_NAME_FLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVE_FILE, SAVE_DUMP, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG, REACTINPUT,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

SPECIAL NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREV_OUTPUT;
NEW     NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREV_OUTPUT;

SPECIAL PROVEL,PROVEN,NEWPROVEN,INTLIST,INTENT,PRINTALL;
SPECIAL OLDGIBB, OLDMISS;
NEW ?!ANAPHLISTNEW;

SPECIAL LAMDA, INPUTFILEAREA;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
 THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX, PL PREFIX, BL PREFIX, NUMED PREFIX;

EXPR INIT();	SELECTINPUTN( '(PAR BLF), INPUTFILE);
EXPR INITFB(); BEGIN EVAL '(DSKIN(RANDOM.LAP)); LAMDA8; INITF(); INITB(); END;
EXPR TESTM();	TEST_PATTERN();

EXPR LAMBDANAME(L);  EQUAL( CHRVAL(L), LAMDA);


EXPR PARRY();	% ************ TOP LEVEL ROUTINE *********** %

	BEGIN 
	TERPRI PRINC "READY:" ;
	WHILE T DO
	  IF ERRSET(  PARRY2() , NIL)
	  THEN ERROR(SSENT, "TOP-LEVEL LISP ERROR " CAT TRACE_MEM CAT !ANAPHLIST ) 
	  ALSO TERPRI NIL 
	  ALSO TERPRI PRINTSTR("WHAT DO YOU MEAN BY THAT");
	END;

EXPR PARRY2();

		BEGIN	NEW A,B;
		BUG0;
		IF SAVE_DUMP THEN SAVEJOB( SAVE_DUMP, 'SAV );
			%  PROGRAM WILL START HERE AGAIN IF SYSTEM CRASHES %

		IF NOT_LAST_INPUT() THEN TERPRI PRINC "READY:" ;
		BUG0; EXPERIMENT();
		BUG1;
		AERRSET(TESTM(),NIL);  IF ATOM A THEN 	ERROR(A,
		  "PATTERNMATCH ERROR" CAT STR < NEXT_CHAR,SSENT,INPUTQUES > ) 
		 ALSO ERR(NIL);
		BUG2;
		AA;	PM2INPUTPMINPUT;  PMINPUTA;
		IF LENGTH(SSENT)=1 THEN ACHOOSE 'SILENCE;
% *** %		ANALYZE(T);
		BUG3;
		IF LAMBDANAME(A) THEN ANIL;
		IF A  ATOM A  BGET(A,'MEQV) THEN AB;
		REACTINPUTA;
		WINDOW(9,T,A);
		READLAMBDA(A);  WINDOW(9,NIL,GET(A,'BONDVALUE));
		BUG4;
		IF ERRSET(REACT ( < A, Q(SSENT), SSENT > ), NIL) THEN
			ERROR(A,"ERROR IN REACT " CAT SSENT)  ALSO ERR(NIL);
		BUG70;
		IF ENDE THEN TRACEVTRACEV ALSO MODIFVAR() ALSO WINXIT()
			ALSO SWAPP()  ALSO EXIT();
		BUG80;
		END;  

EXPR INITB();			% INITIALIZATION FUNCTION %
	BEGIN 	EIGHT();  NOUUO(T);
	OPARINITIALIZE();	% INITIALIZES OPAR3	%
	READBONDS('PDATB);
	SETUPSTL();
	INPUTFILEAREA'(1 3);  DIAFILEAREA'(DIA KMC);
	GCGAG(NIL);
	CHANGEL('CHANGE);
	DELNOBUG0;	OLDMISSOLDGIBB0;
	INPUTNOREPEATNOSPECFNNOMISCNONEWTOPICNO0;
	HLISTOLDTOPICOLDTOPICSNIL;
	END;

EXPR REACTPRINT(L);	% FORMATS AND PRINTS THE OUTPUT TO TTY AND DIA FILE %
	BEGIN	NEW SENT, ISENT, N;
	SENT  L;
	%       SUPPRESS NON-VERBALS HERE	%
	BUG43;
	IF SUPPRESS  SENT  ATOM SENT THEN SENTSENT;
	SENT  IF SENT THEN STRINGATE (SENT) ELSE " ";
	TERPRI NIL;
	PRINTSTR  SENT;
	ISENT  INPUTSSENT;
	BUG44;
	ISENTSTRINGATE(IF ISENT  ISENT THEN REVERSE(ISENT) ELSE ISENT);
	N < PMINPUT, GET(REACTINPUT,'BONDVALUE), TRACE_MEM, NEWPROVEN, INTENT>;
	BUG45;

	IF SAVE_FILE THEN  (
	 IF ERRSET( TO_FILE(ISENT, SENT, N ) ,NIL) 
	  THEN ERROR(DIACHARNO, "ERROR IN TO_FILE" CAT ISENT CAT SENT )   ) ;
	BUG46;
	INPUTSSENTNIL;
	END;


EXPR PMIN();  PMINITIALIZE();

EXPR DOSF(L);   % THIS DOES THE SEMANTIC FN (PROTECTED BY ERRSET) AND RETURNS A LAMBDA OUTPUT %

	BEGIN NEW A,B;
	IF ATOM BERRSET( IF LAMBDANAME(L)  (AGET(L,'SF))  AEVAL(A) THEN A, NIL)  
	THEN ERROR("BAD SF",<L,B>)
	ELSE BB   ALSO ( IF LAMBDANAME(B) THEN ?!OUTPUTB ALSO BNIL )
	ALSO RETURN B;
	END;

EXPR CHOOSELEAD(); '(BOOKIESET GAMBLERSET HORSERACINGSET GANGSTERSET)[ RANDOM(4) ];

	  %   PRINT OUT VALUES OF VARIABLES   %

EXPR PRINTVARS();
      BEGIN
	BUFFER(T);  TERPRI NIL;
	PRINC("      FEAR = ");  PRINTSTR NUMED FEAR;
	PRINC("     ANGER = ");  PRINTSTR NUMED ANGER;
	PRINC("     SHAME = ");  PRINTSTR NUMED HURT;
	BUFFER(NIL);
      END;

EXPR WPRINTVARS();
      BEGIN  NEW A;
	AWINSUP(T);  % SUPPRESS AND GET OLD SETTING %
	WINDOW(41,T,"      FEAR = " CAT NUMED FEAR);
	WINDOW(41,T,"     ANGER = " CAT NUMED ANGER);
	WINDOW(41,T,"     SHAME = " CAT NUMED HURT);
	WINDOW(41,T,"  " );
	IF A THEN WINDIS();  WINSUP(A); %IF OLD SETTING OFF, THEN DISPLAY AND RESET %
      END;

% ANGERFEARMODE  %

EXPR NOT_LAST_INPUT();  NOT ( EQ( NEXT_CHAR, CR) OR EQ( NEXT_CHAR, LF) ) ;

% ANGERFEARMODE RESPONDS TO HIGH ANGER AND FEAR LEVELS IF NO SPECIFIC EMOTIONS ARE AFFECTED %

EXPR ANGERFEARMODE(TOPIC);

	BEGIN
	IF MEMQ(TOPIC, GET('FLARELIST,'SETS)) OR 
		MEMQ(TOPIC, '(MAFIA BYE IYOUME STRONGFEELINGS FEELINGS GAMES))
	  THEN RETURN NIL;
	BUG14;
	RETURN ( IF FEAR14 THEN FEARMODE() ELSE ANGERMODE() ) ;
	END;

EXPR ANGERMODE ();
	IF ANGER GREATERP 17.5 THEN  CHOOSE 'ANGER ELSE  CHOOSE 'HOSTILEREPLIES ;

EXPR FEARMODE ();
	IF FEAR GREATERP 18.4 THEN  ENDET  ALSO  CHOOSE 'EXIT
		%   DISTINGUISH BETWEEN QUESTIONS AND STATEMENTS OF 'OTHER   %
	ELSE IF BL 'DDHARM  BL 'DHELPFUL  BL 'DMAFIA THEN ((FEARFEAR-1)  NIL)
	ELSE IF STYPE='Q THEN CHOOSE 'THREATQ ELSE  CHOOSE 'AFRAID;

% TOPICANALYZE  RECORDS THE NUMBER OF OLD TOPICS, CHANGED TOPICS, AND THE PREVIOUS TOPIC %

EXPR TOPICANALYZE();

	BEGIN  IF STOPIC THEN RETURN NIL;
	IF STOPIC MEMQ '(ANAPH FACTS STRONGFEELINGS GREETINGS) THEN RETURN NIL;
	IF STOPIC=OLDTOPIC THEN RETURN NIL;
	NEWTOPICNONEWTOPICNO+1;
	OLDTOPICSCONS(OLDTOPIC,OLDTOPICS);
	OLDTOPICSTOPIC;
	END;

EXPR PREVTOPIC();	STOPIC MEMQ OLDTOPICS;

% HISTORY  RECORDS THE SPECIFIC EMOTION THAT WAS AFFECTED BY THIS INPUT %

EXPR HISTORY(L);

	BEGIN  IF L THEN RETURN MEMQ(L, HLIST);
	HLISTNIL;
	IF AJUMP  (AJUMP0.1) THEN ADDH( '(AJUMP MJUMP));
	IF FJUMP  (FJUMP0.1) THEN ADDH( '(FJUMP MJUMP));
	END;

EXPR ADDH(L);   FOR NEW I IN L DO HLISTCONS(I,HLIST);

% REACT2  CALLS REPLYR WITH APPROPRIATE ARGUMENTS AND ENTERS THE INPUT ON THE CONVERSATION LIST %

EXPR REACT2(B);

	BEGIN NEW A; ?!EXHAUSTNIL;

	IF LAMBDANAME(B) THEN ERROR("NONLAMBDA INTO REACT2",B) ALSO RETURN NIL;

	IF ?!OUTPUT	% ALREADY HAVE SENTENCE IN ?!OUTPUT %
	  THEN ANDTHEN(<'IN,B>)  ALSO ANDTHEN(<'OUT,NIL>)
	  ALSO RETURN T;

	IF DISKREAD(B) THEN  ERROR("REACT2 ERROR BAD DISKREAD", B) ALSO RETURN NIL;

	ANDTHEN(<'IN, B>);
	RETURN REPLYR(B);

	END;

% REACT3  HANDLES CASES WHEN THE OUTPUT RESPONSES HAVE BEEN EXHAUSTED %

EXPR REACT3(P,STRUC,SENT);	% IF NO !OUTPUT FROM REACT2 THEN DO THIS %

	BEGIN NEW A,B;	BCARN P;

	IF ?!EXHAUST THEN ERROR(<P, STRUC, SENT>,"BAD INPUT IN REACT3");
	%  REPETITIOUS INPUT AND EXHAUSTED REPLIES	%
	IF ( TRACE_MEM='OK ) AND (STOPIC='STRONGFEELINGS) AND REPETITION(B,'IN) 
	  THEN REPEATNOREPEATNO+1 
	  ALSO  ( IF GET(B,'REPEAT) THEN AGET_STORY() )  %LET ONE REPEAT GO BY %
	  ALSO PUTPROP(B,T,'REPEAT) 
	  ALSO  (IF A THEN ACHOOSE 'REPEAT) ;
	IF A  REACT2(A) THEN RETURN A;

	A GET_STORY();
	IF A   REACT2(A)  THEN RETURN A;
	IF AEXHAUSTER() THEN ACHOOSE 'EXHAUST; 
	IF A  REACT2(A) THEN RETURN A;
	END;

	% ********** REACT ******* TOP LEVEL ROUTINE OF THE MEMORY ************ %

EXPR REACT(INPUT);

	BEGIN NEW A,B,SENT,STRUC,FOUND,FOUND2; 	BUG10;
	STRUC CAR INPUT;  STYPE CADR INPUT;  SENTINPUT;

	INPUTSSENTSSENT CONS INPUTSSENT;	% SET ALL THE VARIABLES %
	TRACE_MEMNIL;	INPUTNOINPUTNO+1;
	?!ANAPHLISTNEW?!EXHAUSTNIL; ?!OUTPUTWDFLAGNIL; CHOSENNIL;
	IF DOC_NAME_FLAG THEN DOCNAMEGETDOCNAME();
	BUG11;

	IF ( INPUTNO=2 ) AND ERRNAME  THEN ERRNAMET  	% SAVE A POINTER TO THE DIA FILE %
	  ALSO ERROR( (IF PTYJOB() THEN " PTYJOB" ELSE " ")
	   CAT (IF SAVE_FILE THEN " NSAVED" ELSE " ") , NIL);
	BUG12;
	IF STRUC  READLAMBDA(STRUC) THEN REACTTOSTRUCNIL ALSO TRACE_MEM'NOT_IN_MEMORY;

	WINDOWSET(2);
	WINDOW(51,T,GET(STRUC,'TOPIC));
	IF A  GET(STRUC,'UNIT) THEN WINDOW(52,T,A);

	WINDOW(31,T,'PREPROCESS);
	REACTTOCHECKINPUT(STRUC);	% PREPROCESS THE INPUT %
	IF REACTTO  READLAMBDA(REACTTO) THEN REACTTOSTRUCNIL;
	BUG14;

	IF REACTTO  STRUC THEN (  
		(IF REACTTOSPECFN(STRUC) THEN TRACE_MEM'SPECIALANAPH   % LOOK FOR ANAPHORA %
			ALSO SPECFNNOSPECFNNO+1 )  OR
		(IF REACTTOMEMFIND(STRUC)THEN TRACE_MEM'OK)  ) ;	% LOOK UP NORMAL INPUT %
	IF REACTTO='QUIT THEN REACTTONIL ALSO TRACE_MEM'NOSPECIALANAPH;
	IF READLAMBDA(REACTTO) THEN REACTTONIL;
	BUG15;
	IF REACTTO  DELFLAG  REACTTOSKEYWD(STYPE,INPUTQUES) 
		THEN TRACE_MEM'KEYWORD;

	IF READLAMBDA(REACTTO) THEN REACTTONIL;

	BUG16;
%***%   ANALYZE(T);

	STOPIC CARN GET(STRUC, 'TOPIC);
	TOPICANALYZE();	% ANALYZE THE CURRENT TOPIC %
	WINDOW(31,T,'INFERENCES);
	IF ERRSET( INFERENCE(),NIL) THEN ERROR("INFERENCE ERROR", PROVEL);
	WINDOW(31,T,'AFFECTS);
	IF ERRSET( AFFECT(),NIL) THEN ERROR("AFFECT ERROR", ACTION);
	WINDOW(31,T,'INTENTIONS);
	IF ERRSET( FOUNDDOINTENT(),NIL) THEN ERROR("DOINTENT", INTENT);
	IF FOUND THEN TRACE_MEM'INTENT;
	WINDOW(31,T,'ACTIONS);
	BUG17;
	IF FOUND  REACTTO THEN FOUNDREACTTO;

	  % IF THERE IS NOTHING IN FOUND, THEN WE HAVE TO PUNT AND TAKE A MISCELLANEOUS RESPONSE %

	IF FOUND THEN BEGIN IF STYPE='Q THEN FOUNDMISCQ(SENT) ELSE FOUNDMISCS(SENT);
		MISCNOMISCNO+1;
		IF TRACE_MEM  FOUND THEN TRACE_MEM'NO_PATTERN; END;
	BUG18;


	IF READLAMBDA(FOUND) THEN  FOUNDNIL;
	BUG20;

	REACTTOFOUND;  BNIL;
	% DO SEMANTIC FUNCTION, RESULT WILL BE EITHER NAME OR ACTUAL SENTENCE %
	FOUND IF BDOSF(FOUND) THEN ( IF ADOSF(B) THEN A ELSE B ) ELSE FOUND;
	BUG22;

	IF NOT_LAST_INPUT() THEN RETURN NIL;
	  % QUIT HERE IF THERE IS ANOTHER INPUT SENTENCE ON THE INPUT LINE %
%***%   ANALYZE(T);

	IF CARN GET(FOUND,'TOPIC)='MAFIA THEN DELNODELNO+1; % RECORD NUMBER OF DELUSION STMTS %
	REACT2(FOUND);  % GET THE ENGLISH SENTENCE INTO ?!OUTPUT %
	BUG30;

	IF ?!OUTPUT THEN FOUND2REACT3(FOUND,STRUC,SENT); % TRY AGAIN TO GET ENGLISH OUTPUT %

	BUG35;
	?!ANAPHLISTOLD?!ANAPHLIST;	?!ANAPHLIST?!ANAPHLISTNEW;  % UPDATE ANAPHLIST %

	IF ?!OUTPUT  ?!OUTPUT THEN   % RESCAN OUTPUT FOR FLARE AND DELUSIONAL WORDS %
	   IF ATOM ERRSET(  ASCAN( CANONA(?!OUTPUT) ,NIL) ,NIL  ) THEN
		ERROR("ASCAN" CAT ?!OUTPUT, FOUND);
	BUG40;

	?!LAST_OUTPUTFOUND;
%***%   ANALYZE(T);
	BUG42;
	WINDOW(31,T,'OUTPUT); PREV_OUTPUT?!OUTPUT;
	WINDOW(49,T,IF ATOM ?!OUTPUT THEN ?!OUTPUT ELSE ?!OUTPUT );
	IF ATOM ERRSET( REACTPRINT(?!OUTPUT), NIL) THEN  % PRINT OUTPUT TO TTY AND DIA FILE %
		ERROR("REACTPRINT" CAT INPUTSSENT CAT ?!OUTPUT, FOUND);
	INPUTSSENTNIL;
	BUG48;
	IF ATOM ERRSET( BEGIN
	HISTORY(NIL);	% REMEMBER CURRENT THINGS FOR HISTORY %
	MODIFVAR(); TERPRI NIL;		% UPDATE EMOTION VARIABLES %
	IF WINDOWS THEN WPRINTVARS();

		%  UPDATE STORY LISTS %
	IF LAMBDANAME(?!LAST_OUTPUT) AND AGET(?!LAST_OUTPUT,'STORYNAME)
		THEN DELETEP(A, ?!LAST_OUTPUT, 'STORY);
	IF LAMBDANAME(FOUND2) AND AGET(FOUND2,'STORYNAME)
		THEN DELETEP(A, FOUND2, 'STORY);
	END, NIL) THEN ERROR("ERROR FROM BOTTOM OF REACT",FOUND);

%***%   ANALYZE(T);
	BUG50;
	RETURN FOUND;
	END;

% BINIT, READBEL, READINF %

EXPR BINIT();

	BEGIN
	BAKGAG(T); NOUUO(T); TEN();
	INTLISTINTENTPROVENPROVELNIL;
	PRINTALLNIL;
	READBEL('BEL);
	READINF('INF);
	END;

% FORMAT OF INPUT: ( <BELNAME> <NUMBER> <CLASS> <OPTIONAL OPPOS NAME> <NUMBER> ) %

EXPR READBEL(FILE);	% READ BELIEFS INTO MEMORY AND LINK THEM %

	BEGIN NEW A,B;
	SELECTINPUT(NIL,FILE);
	WHILE ATOM(AERRSET(READDATA()) ) AND AA DO
	  BEGIN
		PUTPROP(A, A, 'NTRUTH);
%		PUTPROP(A, A, 'CLASS);  %
		IF A='INN THEN INTLISTA CONS INTLIST
		    ALSO PUTPROP(A, A, 'CLASS);
		IF BA 
		  THEN PUTPROP(B, B, 'NTRUTH)
%		  ALSO PUTPROP(B, A, 'CLASS)  %
		  ALSO PUTPROP(B, A, 'OPPOS)
		  ALSO PUTPROP(A, B, 'OPPOS);
		BA;
	  END;
	INTLIST  REVERSE(INTLIST);
	PRINTSTR("BELIEF FILE READ, LAST BELIEF: " CAT B );
	END;

% FORMAT OF INPUT: ( <INF NAME> <CONSEQ> <LIST OF ANTECEDENTS> ) %

EXPR READINF(FILE);	% READ INFERENCES INTO MEMORY AND LINK THEM %

	BEGIN NEW A,B;
	SELECTINPUT(NIL,FILE);
	WHILE ATOM(AERRSET(READDATA()) ) AND AA DO
	  IF MEMQ(A,'(TH2 EMOTE)) THEN
	   FOR NEW I IN A DO  PUTPROP(I, CONS(A, GET(I,A)), A)
	ELSE
	  BEGIN BA;
		IF GET(A,'THEOREM) THEN PRINTSTR("DUPLICATE INF: " CAT A);
		PUTPROP(A, A CONS A, 'THEOREM);
		IF GET(CARN A, 'NTRUTH) THEN PRINTSTR("NO BEL: " CAT A);
		% BACKPOINTER FROM ANTECEDENT TO TH NAME %
		FOR NEW I IN A DO 
		  IF ATOM I THEN PUTPROP(I, A CONS GET(I,'TH), 'TH)
		   ALSO IF LAMBDANAME(I)  GET(I,'NTRUTH) THEN PRINTSTR("NO BEL: " CAT I);
	  END;

	PRINTSTR("INF FILE READ, LAST INF: " CAT B );
	END;
% ASSERT, ASSERT2, ADDTO, PROVE, PROVE2, BL, EVALUATE, STATED, INFERENCE %

EXPR POSIT(B);  IF ATOM B THEN ASSERT2(B) ELSE ADDTO(B,B);

% B IS A NAME OF A BELIEF %

EXPR ASSERT(B);		% ASSERT B, AND TRY TO PROVE ANY CONSEQUENCES OF IT %

	T  ASSERT2(B)  PROVE();

EXPR ASSERT2(B);	% ASSERT A NEW BELIEF, AND FIND ALL THEOREMS IN WHICH IT IS THE ANTECEDENT %

	BEGIN NEW A;
	IF AGET(B,'EMOTE) THEN INFEMOTE(B,A,T);
	AGET(B,'OPPOS);
	IF GET(B,'TRUTH) THEN RETURN T;
	IF A  GET(A,'TRUTH) THEN 	% OPPOSITE BELIEF ALREADY TRUE %
	   (IF PRINTALL THEN PRINTSTR("CONTRADICTION : TRYING TO ASSERT " CAT B) )
	   ALSO RETURN T;
	WINDOW(37,NIL,B);
	PUTPROP(B,T,'TRUTH);	% ASSERT %
	IF A THEN PUTPROP(A,NIL,'TRUTH);	% UNASSERT THE OPPOSITE BELIEF %
	IF AGET(B,'TH) THEN PROVELPROVEL @ A;	% FIND THEOREMS %
	PROVENCONS(B,PROVEN);	% RECORD THIS BELIEF %
	NEWPROVENCONS(B,NEWPROVEN);
	END;

EXPR ADDTO(B,N);	% ADDTO A BELIEF, IF THRESHHOLD CROSSED, THEN ASSERT %

	BEGIN NEW A,VAL;
	IF AGET(B,'EMOTE) THEN INFEMOTE(B,A,N);
	IF AGET(B,'TH2) THEN 
		FOR NEW I IN A DO ADDTO(IF ATOM I THEN I ELSE I, N/2);
	AGET(B,'OPPOS);
	IF GET(B,'TRUTH) OR ( A  GET(A,'TRUTH) ) THEN RETURN T;  % QUIT IF TRUE, OR OPPOSITE TRUE %
	WINDOW(37,NIL,<B,N>);
	VALN+GET0(B,'NTRUTH);
	IF 'INN=GET(B,'CLASS) THEN (	% UPDATE VALUE %
	  IF VAL10 THEN VAL9 ELSE IF VAL0 THEN VAL0 ) ;
	PUTPROP(B, VAL, 'NTRUTH);
	IF VAL  10 THEN ASSERT2(B);	% ASSERT IF THRESHHOLD CROSSED %
	END;

EXPR GET0(I,V);		% RETURNS A NUMBER FOR GET %
	BEGIN NEW A; AGET(I,V);
	RETURN   IF NUMBERP(A) THEN A ELSE 0;
	END;

EXPR PROVE();	% DO PROVE2 REPEATEDLY ON PROVEL, THE LIST OF THEOREMS TO BE PROVED %

	WHILE PROVEL DO PROVE2(PROVEL)  PROVELPROVEL;

% TH IS A THEOREM NAME FROM THE TOP OF PROVEL %

EXPR PROVE2(TH);	% TRY TO PROVE A THEOREM TH %

	BEGIN NEW A,B,C;
	IF PRINTALL = 2 THEN PRINTSTR(PROVEL);
	IF AGET(TH,'THEOREM) THEN RETURN NIL;
	  % IF BELIEF ALREADY PROVEN THEN DON'T DO IT  %
	BCARN A; IF BL B THEN RETURN NIL;
	% C IS THE CONSEQUENT, A IS A LIST OF ANTECEDENTS %
	WINDOW(35,T,A);
	CA; BT;
	FOR NEW I IN A DO BB  EVALUATE(I);   % TRY EACH ANTECEDENT AND "AND" THEM TOGETHER %
	IF B THEN  ( IF PRINTALL THEN PRINTSTR(C CAT " PROVEN") ) ALSO  POSIT(C) 
		ALSO WINDOW(36,T,A);
	END;

EXPR EVALUATE(I);	% EVALUATE AN ANTECEDENT "I" %

	IF ATOM I THEN		% EITHER AN INPUT WHICH IS STATED, OR A BELIEF WHICH IS TRUE %
	  ( IF LAMBDANAME(I) THEN STATED(I) ELSE BL I )
	ELSE IF I='NOT THEN NOT BL I
	ELSE EVAL(I);	% ELSE A FUNCTION FOR LISP TO EVALUATE %

EXPR BL(B);	% RETURNS T IF BELIEF B IS TRUE, OR INTENTION B IS OVER ITS THRESHHOLD %
	IF ATOM B THEN ERROR("BL NOT ATOM", B) ALSO NIL
	ELSE  IF GET(B,'CLASS)='INN THEN ( GET(B,'NTRUTH)5 ) ELSE  GET(B,'TRUTH);

EXPR STATED(I);	EQ(REACTTO,I);

% THINK  TAKES ALL THE NEW FACTS FROM THIS INPUT AND PROVES ALL IT CAN ABOUT THE WORLD %

EXPR INFERENCE();

	BEGIN NEW A; SPECIAL PARA, SPECFNRA;
	NEWPROVENNIL;
	PARAGREATERP(MISTRUST,7);	% PARANOID PARAMETER -- MAKES SOME BELIEFS POSSIBLE %
	IF STOPIC='GREETINGS THEN SPECFNNOSPECFNNO+1;
	SPECFNRA100*SPECFNNO/INPUTNO;
	PROVEL'(IF730 IF740 IF750 IF760 IF770 IF350 IF380 IF566 IF884	% TRY THESE EVERY TIME %
		%	IF205 IF210 %     IF225    );
	IF DOC_NAME_FLAG THEN PROVEL 'IF331 CONS PROVEL;
	IF STOPIC='MAFIA THEN PROVEL 'IF888 CONS PROVEL;
	AGET(REACTTO,'TH);	% THE INPUT MAY HAVE ASSOCIATED INFERENCES %
	IF A THEN PROVELPROVEL @ A;
	IF AGET(REACTTO,'TH2) THEN FOR NEW I IN A DO POSIT(I);
	PROVE();	% PROVE ALL THATS POSSIBLE %
	IF PRINTALL THEN PRINT(PROVEN);
	END;

END.  _EOF_ 
