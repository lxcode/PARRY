BEGIN

% MASTER LIST OF GLOBAL VARIABLES  %

%			*** GLOBAL VARIABLES***

!ANAPHLIST	is the current list of anaphora dotted-pairs.
!ANAPHLISTOLD	is the previous list of anaphora dotted-pairs.
!ANAPHLISTNEW	is the next list of anaphora dotted-pairs to go into anaphlist
!ALLANAPHS	is a list of lists - ((who they he)(he who)(they who)....)
!CLIST		is a pointer to the first element of the conversation list.
!CLAST		is a pointer to the last element of the conversation list.
!LAST_ANDTHEN	is either IN or OUT as the last ANDTHEN processed
!LASTIN		points to atom under which is stored the last semantic unit
		inputed by the doctor.
!LASTOUT	points to the atom under which is stored the last semantic
		unit outputed by Parry.

!ERROR		contains a list of errors made
!EXHAUST	is true if a set of responses is exhausted and the exhaust responses are to be used
		  it is set by SELECT_SENTENCE  and used at the end of REACT2
!OUTPUT		is the output of parry, to be sent whereever
!LAST_OUTPUT	is the -name of the last output

INPUTQUES	is a list of dotted pairs from the pattern matcher to the memory
			each pair is (canonical 5-letter atom . input word)

         %


SPECIAL ?!ANAPHLIST,?!ANAPHLISTNEW,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LAST_ANDTHEN,
	?!OUTPUT,?!LAST_OUTPUT, ?!EXHAUST, ?!ERROR,

	INPUTQUES,SSENT,DO_SPELL,NEXT_CHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOC_NAME_FLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVE_FILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX;

% DISKREAD, CARN, LAMBDANAME, ALPHANAME    %

EXPR LAMBDANAME(L);  EQUAL (CHRVAL (L), 8); % RETURNS T IF THE FIRST CHAR OF L IS  %

EXPR ALPHANAME(L);  EQUAL (CHRVAL (L), 2);  % RETURNS T IF THE FIRST CHAR OF L IS  %

% READLAMBDA ATTEMPTS TO READ IN A SEMANTIC FUNCTION (FRAME) FROM THE MEMORY
	GIVEN A LAMBDA NUMBER AS INPUT %
EXPR READLAMBDA(A);

	BEGIN IF LAMBDANAME(A) THEN RETURN NIL;
	IF DISKREAD(A) THEN RETURN T;
	ERROR("BAD DISKREAD",A);
	END;

%	 DOES DISKREAD2 PROTECTED BY AN ERRSET;
	 ERRORS MAY OCCUR IF THE MEMORY FILE HAS MISMATCHED PARENS  %
EXPR DISKREAD(NAME); 

	BEGIN NEW A;  RETURN
	IF AERRSET( DISKREAD2(NAME), NIL) THEN ERROR("ERROR IN DISKREAD", NAME)
	  ALSO NIL ELSE A;
	END;

%	GIVEN A  OR  NUMBER AS INPUT, READS IN ONE DISK SEXPR 
	IF THE SEXPR IS ALREADY IN CORE, IT JUST RETURNS T
	OTHERWISE IT CALLS BEL OR ENG TO PROPERLY LINK ALL THE INFO INTO THE MEMORY %
	
EXPR DISKREAD2(NAME);

	BEGIN NEW A,B,CHARNO;
	IF GET(NAME,'INCORE) THEN RETURN T;
	IF GET('DSKLOC,'SUBR) THEN ADSKLOC(NAME);  % GET THE CHAR NO OF THE SEXPR %
	IF A THEN RETURN NIL;  % NOT THERE %
	CHARNOA;
	 % CHARNO IS THE CHARACTER NUMBER IN THE FILE THAT THE SEXPR NAME BEGINS ON %
	 % IF A RECNO IS NEEDED, IT IS CHARNO/OCTAL 1200 + 1 (FIRST RECORD IS REC 1 %

	CHANSAVEINC(NIL,NIL);
	INIT();		% INITIALIZE THE READ CHANNEL FOR THE MEMORY FILE %
	INC(INCHAN,NIL);
	CHSETI(INCHAN,CHARNO);  % SET THE INPUT POINTER TO THE CORRECT SEXPR %
	BREAD();
	INC(CHANSAVE,NIL);

	IF B THEN PUTPROP(NAME,T,'INCORE);
	IF B='?#B THEN BEL( B) ELSE IF B='?#E THEN ENG( B);  % LINK UP IN MEMORY %
	RETURN B;
	END;

EXPR CARN(L);  IF ATOM L THEN L ELSE L;  % RETURNS CAR OF A LIST %

%	BEL AND ENG TAKE AN SEXPR FROM THE MEMORY FILE (PDAT) AND LINK
	THE INFORMATION IN THE MEMORY IN THE RIGHT WAY %
	% READ IN SEMANTS AND SURFACE AND STORE UNDER LAMBDAS AND ALPHAS %
	% X IS THE LIST WITHOUT THE B OR E %
	%   X LOOKS LIKE:  ( 17 100 (LOC I HOSP) LIT (...)  ) %

EXPR BEL(X);
	BEGIN NEW NAME,TRUTH,UNIT;
	NAME CAR X; TRUTH CADR X; UNIT CADDR X;
	IF NULL X OR NULL X OR NULL X OR NUMBERP(TRUTH)
		THEN ERROR("B BAD INPUT",X) ALSO RETURN NIL;
	IF GET(NAME,'BONDVALUE) THEN ERROR("BAD INPUT-DOUBLE ENTRY", NAME);
	PUTPROP(NAME,UNIT,'BONDVALUE);
	X CDR X;
	WHILE X CDDR X DO   % PUT THEM ON THE PROPERTY LIST OF THE  NAME %
	  IF ATOM CAR X OR NULL X THEN ERROR("BAD INPUT ", NAME) ALSO RETURN NIL
		ELSE  PUTPROP(NAME,CADR X,CAR X);
	RETURN NAME;
	END;

	%------------------------------------------------------------%
EXPR ENG(X);
	BEGIN NEW UNIT,ERROR; 
	IF NULL X OR NULL X OR NULL X 
		THEN ERROR("E BAD INPUT", X) ALSO RETURN NIL;
	UNIT CAR X;
	IF GET(UNIT,'NORMAL)  GET(UNIT,'EMBQ) 
		THEN ERROR("BAD INPUT-DOUBLE ENTRY", UNIT);
	X CDR X;
	IF CAR X='ANAPH THEN  XCDR X 	% PUT ANAPH ON PROPERTY LIST %
	   ALSO PUTPROP(UNIT, CAR X, 'ANAPH)	   
	   ALSO XCDR X;
	IF CAR X='EXH THEN PUTPROP(UNIT, CADR X, CAR X)
		ALSO XCDDR X;

	DO BEGIN  % PUT SENTENCES ON THE PROPERTY LIST %
	   IF (NULL X) OR (NULL X) OR (ATOM X) OR (ATOM X) 
		THEN ERROR("E BAD INPUT",UNIT) 	ALSO ERRORT	ALSO RETURN NIL;
	   PUTPROP(UNIT,CADR X,CAR X);
	   END
	UNTIL ERROR OR  X CDDR X;
	IF GET(UNIT,'NORMAL) THEN ERROR("NO NORMAL SENTS",UNIT);
	RETURN UNIT;
	END;
	%-- REPLYR, ANTHEN, EXPRESS, SELSENTENCE, SAY ------%

% REPLYR IS THE FUNCTION WHICH SELECTS AND EXPRESSES AN OUTPUT SENTENCE
	AFTER THE PROPER  NUMBER HAS BEEN DETERMINED BY THE MEMORY.
	A SENTENCE GENERATOR WOULD REPLACE THIS FUNCTION %
% REPLYR  ADDS TO CONVERSATION LIST, AND EXPRESSES %
	% SEMANT IS  NAME, TYPE=D OR Q, CLASS IS RESP   INTO EXPRESS %
	% CALLS  ANDTHEN, EXPRESS %

EXPR REPLYR(SEMANT);

	BEGIN   NEW A;
	IF SEMANT THEN ERROR(NIL,"NOSEMANT IN REPLYR")  ALSO RETURN NIL;
	ANDTHEN(<'OUT,SEMANT>);
	AEXPRESS(SEMANT,'RESP);
	?!OUTPUT  IF A  WDFLAG THEN (A @ LASTWORD(WDFLAG)) ELSE A;
	WDFLAGNIL;  RETURN ?!OUTPUT;
	END;

	%-------------------------------------------------------------------%
% ANDTHEN PUTS THING ON THE CONVERSATION LIST %
	% INPUT THING IS A LIST OF INFORMATION ABOUT THE CURRENT SEMANTS %

EXPR ANDTHEN(THING);

	BEGIN NEW A;
	  % IF THE LAST THING ADDED TO THE CONVERSATION LIST, THEN DONT DO THIS ONE %
	IF ?!LAST_ANDTHEN = THING THEN RETURN NIL; 
	?!CLIST THING CONS ?!CLIST;
	IF THING = 'IN THEN ?!LASTINA  ELSE  IF THING = 'OUT THEN ?!LASTOUTA;
	?!LAST_ANDTHENTHING;
	RETURN ?!CLIST;
	END;

	%-------------------------------------------------------------------%
	%--EXPRESS -------------%
	% SAYS SEMANT USING CLASS, HAVING THE SUBCL AS THE NECESSARY SLOT, IN MODE %
	%  SEMANT = 17, CLASS = SQR OR LIT, 
	      SUBCL = HOSPITAL OR NIL; APPLIES TO SQR, MODE = NORMAL OR EMBD OR EMBQ %
	%    SUBCL IS THE NAME OF THE SLOT WHICH HAD THE QMARK %

EXPR EXPRESS(SEMANT,CLASS);

	BEGIN NEW A,BOND,C,K;
	DISKREAD(SEMANT);
	A GET(SEMANT,CLASS);
	BOND GET(SEMANT,'BONDVALUE);

	  % USE PREDICATE FOR FINDING CLASS %
	IF (NULL A)  BOND   (CGET(BOND,'UNIT))    DISKREAD(C)
	   THEN  A GET(C,CLASS) ;

	  %  ONLY QUIT IF THERE IS NO RESP   %
	IF NULL A  NULL ( AGET(SEMANT,'RESP) )
	   THEN ERROR("NO CLASS " CAT CLASS, SEMANT)
	   ALSO RETURN NIL;

	  %SET UP ANAPHS FOR NEXT INPUT  %
	IF KGET(SEMANT,'ANAPH) THEN  ADDANAPH(K);

	A SELSENTENCE(A);
	RETURN  IF A THEN  SAY(A,CDR BOND);
	END;

	%-------------------------------------------------------------------%
	%-  SELSENTENCE  ---------------%
	% SELECTS AND RETURNS A  SENTENCE (AN ), ADDING TO THE ANAPHORA LIST%
	% INPUT UNIT IS AN  NUMBER -- LIKE 17, CLASS IS LIKE NORMAL %
	% DELETES THE SENTENCE FROM MEMORY  %

	% CALLS ADDANAPH %

EXPR SELSENTENCE(UNIT);

	BEGIN NEW SENTS,S,A,ANAPH,CLASS;	CLASS'NORMAL;
	IF DISKREAD(UNIT) THEN RETURN NIL;	% READ FROM DISK INTO MEMORY %

	AGET(UNIT,CLASS);  % USE NORMAL REPONSES AS DEFAULT %
	ANAPHGET(UNIT,'ANAPH);
	SENTS A;
	IF NULL SENTS THEN ?!EXHAUSTT ALSO RETURN NIL;  % IF NO SENTS THEN SET THE EXHAUST FLAG %

	%  IF EXH IS T, THEN TAKE THE SENTENCES IN ORDER, OTHERWISE CHOOSE RANDOMLY %
	IF GET(UNIT,'EXH) THEN A1 ELSE ARANDOM(LENGTH SENTS);
	SSENTS[A];
	PUTPROP(UNIT, DELETEN(SENTS,A), CLASS);		% DELETE THE SENTENCE FROM MEMORY %

	IF ATOM ANAPH  ANAPH THEN ANAPH EVAL(ANAPH);
	ADDANAPH(ANAPH);	% ADD ANAPH FOR THIS SENTENCE %
	RETURN S;
	END;

%	RETURNS THE LIST L MINUS THE NTH ELEMENT %

EXPR DELETEN(L,N);  IF N=1 THEN L ELSE L CONS DELETEN(L, N-1);

% SAY  TAKES A LIST OF ENGLISH OR ARGUMENTS TO BE FILLED AND PRODUCES AN ENGLISH SENTENCE %

	% L MAY BE A LIST OF ENGLISH WORDS REPRESENTING THE OUTPUT SENTENCE %
	% L MAY ALSO BE A LIST OF ONE ELEMENT, WHICH IS A LIST OF ARGUMENTS TO EXPRESS %
	% THE FIRST ARG SELECTS FROM ARGS WHICH  NUMBER TO TAKE %
	% CALLS EXPRESS  %

EXPR SAY(L,ARGS);
	IF ATOM L  NUMBERP CAAR L THEN EXPRESS( ARGS[CAAR L], CADAR L) ELSE L;
% ANAPHORA ROUTINES, ADDANAPH  %

% ADDANAPH ADDS STUFF FROM ANAPHS FROM  ON TO GLOBAL ANAPHORA LIST %

EXPR ADDANAPH(L);

	BEGIN NEW A;
	FOR NEW I IN L DO
	   IF A ASSOC(CAR I,?!ANAPHLISTNEW)
		% IF ALREADY ON ANAPH LIST THEN REPLACE %
	   THEN RPLACD(A,CDR I)
	   ELSE ?!ANAPHLISTNEW  I CONS ?!ANAPHLISTNEW ;
	RETURN ?!ANAPHLISTNEW;
	END;

EXPR RANDOM(N);  1;  % GETS REPLACE BY RANDOM.LAP, LOADED IN AFTER THIS FUNCTION %

% SPECFN CALLS THE SPECIAL FN IF THERE IS ONE %

EXPR SPECFN(STRUC);
	BEGIN NEW A, NAME;
	NAME GET( STRUC, 'UNIT);	IF NAME THEN RETURN NIL;  % IE, NOT AN ANAPH %
	IF MEMBER ( NAME, '(GO_ON ELAB WHO WHAT)) THEN   % CALL THE SPEC FN PROTECTED BY ERRSET %
	  ( IF ATOM AERRSET( EVAL< NAME, NIL,T >, NIL) THEN ERROR("SPECFN",NAME)
		ALSO ANIL  ELSE AA )
	  ALSO RETURN(IF A THEN A ELSE 'QUIT);
	% QUIT MEANS THERE WAS AN ANAPHORA, BUT WE DIDNT HAVE THE POINTER FOR IT IN MEMORY %
	IF ASSOC(NAME, ?!ALLANAPHS ) 
		THEN A GENL( STRUC, T, NAME ) 
		ALSO RETURN (IF A THEN A ELSE 'QUIT );
	END;

% GO_ON, ELAB, WHO, WHAT
	TRY TO GET THE ANAPHORA, ELSE USE A STORY %

EXPR GO_ON(L,F);

	BEGIN NEW A;
	IF A THEN AGET_ANAPH('GO_ON);
	IF A THEN AGET_STORY();
	IF A AND F THEN ANDTHEN(<'IN,GET('GO_ON,'UNIT)>);
	RETURN A;
	END;

EXPR ELAB(L,F);

	BEGIN NEW A; 
	IF A THEN AGET_ANAPH('ELAB);
	IF A THEN AGET_STORY();
	IF A AND F THEN AGO_ON(L,NIL);
	IF A AND F THEN ANDTHEN(<'IN,GET('ELAB,'UNIT)>);
	RETURN A;
	END;

EXPR GENL(L,F,ANAPH);		% TRY THE ANAPH, ELSE TRY GO_ON  %

	BEGIN NEW A; ANIL;
	IF A THEN AGET_ANAPH(ANAPH);
	IF A THEN AGO_ON(L,NIL);
	RETURN A;
	END;

% GET_STORY GETS THE NEXT LINE IN WHATEVER STORY IS BEING TALKED ABOUT %
	%  IT GETS THE TOPIC EITHER FROM THE CURRENT INPUT, OR FROM THE PREVIOUS INPUT %
	%  IT THEN LOCATES THE STORY NAME, AND SELECTS THE NEXT ONE WHICH HASNT BEEN USED %

EXPR GET_STORY();

	BEGIN NEW B,C; 	%  TOPIC %
	IF (BCARN GET(REACTTO, 'TOPIC) )     % TRY CURRENT INPUT TOPIC %
	%	ALREADY A SETNAME		GET CANONICAL WD AND SET  %
	 (IF GET(B,'WORDS) THEN T ELSE (BCARN SYNNYM(B))  (BGET(B,'SET)) )
	   THEN CB;
	IF C  (BCARN GET(?!LAST_OUTPUT, 'TOPIC) ) 	% TRY PREVIOUS INPUT TOPIC %
	%	ALREADY A SETNAME		GET CANONICAL WD AND SET  %
	 (IF GET(B,'WORDS) THEN T ELSE (BCARN SYNNYM(B))  (BGET(B,'SET)) )
	   THEN CB;
	IF C THEN RETURN NIL;	% NO STORY FROM EITHER %
	IF BGET(C,'STORY) 
	 THEN  DELETEP(C,CARN B, 'STORY)  ALSO RETURN CARN B;
	IF MEMQ(C,GET('FLARELIST,'SETS)) THEN RETURN FLSTMT(C);
	END;

% GET_ANAPH TAKES AN ANAPH NAME AS INPUT (EG THEY, GO_ON, WHO) AND LOOKS
	ON THE CURRENT ANAPH LIST IF ITS NOT NULL, ELSE LOOKS ON THE OLD ANAPHLIST.
	IT ALSO USES THE TRANSLATIONS OF ANAPHORA FOUND ON ?!ALLANAPHS %

EXPR GET_ANAPH(L);

	BEGIN NEW ANA,B,ALIST;
	ALIST IF ?!ANAPHLIST THEN ?!ANAPHLIST ELSE ?!ANAPHLISTOLD;
	 % GET ALL ANAPHS WITH APPROX THE SAME MEANING %
	ANAASSOC(L,?!ALLANAPHS);
	FOR NEW J IN  ANA DO  BASSOC(J,ALIST)
		UNTIL B;
	IF B  CDR B  ATOM CDR B THEN RETURN CDR B;
	IF L='THEY  BASSOC(L,?!ANAPHLISTOLD) THEN RETURN CDR B;
	END;

EXPR WHO(L,F);

	BEGIN NEW A;  ANIL;
	AGET_ANAPH('WHO);
	IF LAMBDANAME(A) THEN RETURN A ELSE ANIL;
	IF A THEN AGO_ON(L,NIL);
	RETURN A;
	END;

EXPR WHAT(L,F);

	BEGIN NEW A;
	AGET_ANAPH('WHAT);
	IF L AND GET(A,'BONDVALUE)=L THEN T ELSE ANIL;
	IF A THEN AGO_ON(L,T);
	RETURN A;
	END;

% REPETITION RETURNS T IF SEM ( A  NUMBER ) HAS BEEN USED BEFORE AS TYPE (IN OR OUT) %

EXPR REPETITION(SEM,TYPE);

	BEGIN NEW PTR, FOUND;
	PTR  ?!CLIST;
	WHILE PTR AND FOUND DO
		IF ( PTR = TYPE) AND ( PTR = SEM) AND (PTR  ?!LASTIN) 
		THEN FOUNDT 	ELSE PTR  CDR PTR;
	RETURN FOUND;
	END;
%  READING INDEXES,   SETUPSTL    %
%   THESE ROUTINES READ IN DATA FILES AND INTERCONNECT THEM %

% SETUPSTL  SETS UP STORY AND STORYLIST POINTERS %

EXPR SETUPSTL();	% MUST BE DONE AFTER INITIALIZE IN OPAR3  %

	BEGIN NEW A,B,C;  CT;
	A FOR NEW I IN GET('SENSITIVELIST,'SETS) COLLECT GET(I,'WORDS);
	PUTPROP('SENSITIVELIST, A, 'WORDS);
	A 'DELNSET CONS ( GET('FLARELIST, 'SETS) @ GET('SETLIST, 'SETS) ) ;

	FOR NEW I IN A DO	% I IS THE NAME OF A FLARESET %
	  FOR NEW J IN GET(I, 'STORY)  DO   BEGIN  % J IS A -NAME %
		BJ;
		IF B THEN PUTPROP(B, I, 'STORYNAME) ELSE CNIL ALSO PRINT(J);
		END;
	RETURN (IF C THEN '(SET UP OK) ELSE '(SET UP BAD) );
	END;

EXPR READBONDS(FILENAME);	% THIS READS IN A FILE(PDATB) CONTAINING USEFUL INFORMATION ABOUT PDAT %

	BEGIN NEW A;
	SELECTINPUT(NIL, FILENAME);
	WHILE ATOM(AERRSET(READDATA()) ) AND AA DO
		EVAL A;
	PRINTSTR( FILENAME CAT " read in.");
	SELECTINPUT(NIL, NIL);
	END;

EXPR CHANGEL(FILENAME);	
	% THIS READS IN A FILE OF TEMPORARY  NUMBER CHANGES TO MAKE THE PATTERN MATCHER
		AND MEMORY COMPATIBLE %
	BEGIN NEW A;
	SELECTINPUT(NIL,FILENAME);
	WHILE ATOM(AERRSET(READDATA()) ) AND AA DO
		PUTPROP(A, A, 'MEQV);
	PRINTSTR( FILENAME CAT " read in.");
	END;

END.  _EOF_ 
