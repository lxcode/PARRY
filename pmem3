BEGIN

%			*** GLOBAL VARIABLES***

!ANAPHLIST	is the current list of anaphora dotted-pairs.
!ANAPHLISTOLD	is the previous list of anaphora dotted-pairs.
!ALLANAPHS	is a list of lists - ((who they he)(he who)(they who)....)
!CLIST		is a pointer to the first element of the conversation list.
!CLAST		is a pointer to the last element of the conversation list.
!LAST_ANDTHEN	is either IN or OUT as the last ANDTHEN processed
!LASTIN		points to atom under which is stored the last semantic unit
		inputed by the doctor.
!LASTOUT	points to the atom under which is stored the last semantic
		unit outputed by Parry.

!ERROR		contains a list of errors made
!EXHAUST	is true if a set of responses is exhausted and the exhaust responses are to be used
		  it is set by SELECT_SENTENCE  and used at the end of REACT2
!OUTPUT		is the output of parry, to be sent whereever
!LAST_OUTPUT	is the -name of the last output

INPUTQUES	is a list of dotted pairs from the pattern matcher to the memory
			each pair is (canonical 5-letter atom . input word)

         %


SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LAST_ANDTHEN,
	?!OUTPUT,?!LAST_OUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG,

	INPUTQUES,SSENT,DO_SPELL,NEXT_CHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOC_NAME_FLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVE_FILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

 
DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX;

%  SELECTINPUT, READINC, READDATA  %
% ************ THESE ARE ALL INPUT-OUTPUT ROUTINES *************%
 
	% takes a file name (or NIL for TTY) and assigns it to the input channel%

EXPR SELECTINPUT(AREA, FILE);

	BEGIN 
	   IF FILE THEN BEGIN 
			IF AREA THEN INCHANEVAL(<'INPUT,AREA,FILE>)
				ELSE INCHANEVAL(<'INPUT,'DSK:,FILE>)
			END
		   ALSO INC(NIL,NIL)
		   ALSO PRINTSTR(FILE CAT " SELECTED FOR INPUT.")
	   ELSE PRINTSTR("TTY SELECTED FOR INPUT.")
	   ALSO INC(NIL,T);
	END;

EXPR SELECTINPUTN(AREA, FILE);

	   IF FILE THEN  INCHANEVAL(<'INPUT,INPUTFILEAREA,FILE>)
		   ALSO INC(NIL,NIL);

EXPR READINC();

	BEGIN NEW I;  INC(INCHAN,NIL); IREAD(); INC(NIL,NIL); RETURN I; 
	END;

%  READS PAST THE DIRECTORY PAGE IN AN INPUT FILE  %

EXPR READDATA();
	BEGIN NEW A;  AREADINC();
	IF A='COMMENT THEN 
		DO AREADINC() UNTIL ( A='C??;  A='??; )   
		ALSO AREADINC() ;
	RETURN A;
	END;

% INIT_FILE, INIT_TO_FILE, TO_FILE, ERROR_FILE %
% ************* THESE ARE ROUTINES TO SAVE DIALOGS AND ERRORS ************ %

EXPR INITFILE(L);  INIT_FILE(L);

EXPR INIT_FILE(L);
	BEGIN  NEW FILCHAN,I;	SPECIAL DIAFILEAREA,ONEDIA,FILE12;
	EOFPERCENT;	TEN();
	SAVE_FILE  T;
	FILCHAN  EVAL < 'INPUT, DIAFILEAREA, '(PAR2.FIL) > ; 
	INC(FILCHAN,NIL);
	IREAD();
	FILE1 AT("P" CAT I ) CONS 'DIA ;
	FILE2 AT("P" CAT I CAT "A" ) CONS 'DIA ;
	INC(NIL,NIL);
	EVAL < 'OUTPUT, DIAFILEAREA, '(PAR2.FIL) > ; 
	OUTC(T,NIL);
	PRINT(I+1);
	OUTC(NIL,T);
	INIT_TO_FILE(L);
        END;

EXPR INIT_TO_FILE(L);

	BEGIN NEW FILCHAN;
	FILCHAN EVAL < 'OUTPUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	PRINTSTR(L CAT "        ");  PRINC TERPRI EOF ;
	OUTC(NIL,T);
	 IF SUMEX AND ONEDIA THEN BEGIN
	FILCHAN EVAL < 'OUTPUT, DIAFILEAREA, FILE2 > ;
	OUTC(FILCHAN, NIL);
	PRINTSTR( STR(L) CAT "        ");
	OUTC(NIL,T);
	 END;
	DIACHARNOSTRLEN(L) + 4;  FILE12FILE1;
	TO_FILE( LF, LF, LF);
	RETURN DIACHARNO;
	END;

EXPR TO_FILE(L,M,N); IF SUMEX THEN TO_FILE1(L,M,N) ELSE TO_FILE2(L,M,N);

EXPR TO_FILE1(L,M,N);

	BEGIN NEW FILCHAN,C,D,FLAG;  FLAGNIL;
	CHANSAVEINC(NIL,NIL);
	FILCHANEVAL< 'INOUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);

	  % THIS IS TO CORRECT A BUG IN CHSETO WHICH SETS IT TO A MINUS NUMBER
		IF IT HITS A RECORD BOUNDARY EXACTLY  %
	CCHSETO(FILCHAN,NIL);
	IF MINUSP(C) THEN ERROR("TO_FILE MINUS",L) ALSO  
	  BEGIN
	OUTC(NIL,T);	% TO NOT GROW CORE LIKE IT WAS BEFORE %
	FILCHANEVAL< 'INOUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);
	  END   ALSO PRINTSTR("        ")
	  ALSO DCHSETO(FILCHAN,NIL) ALSO FLAGT
	  ALSO IF MINUSP(D) THEN ERROR("TO_FILE MIN AGAIN",L);

	 IF ONEDIA THEN BEGIN

	OUTC(NIL,T);
	FILCHANEVAL< 'INOUT, DIAFILEAREA, FILE2 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);
	IF FLAG THEN PRINTSTR("        ");
	 END;
	DIACHARNOCHSETO(FILCHAN,NIL);
	OUTC(NIL,T);
	INC(CHANSAVE,NIL);
	RETURN DIACHARNO;
	END;

EXPR TO_FILE2(L,M,N);

	BEGIN NEW F,CH;		% FILE12 HAS THE CURRENT GOOD FILE %
	FFILE12;   FILE12IF FILE12=FILE1 THEN FILE2 ELSE FILE1; % SWITCH NAMES %
	CHANSAVEINC(NIL,NIL);
	FILCHANEVAL < 'OUTPUT, DIAFILEAREA, FILE12 > ;
	OUTC(FILCHAN,NIL);
	INCHANEVAL < 'INPUT, DIAFILEAREA, F > ;
	INC(INCHAN,NIL);
	BUFFER(T);
	PRINC(INPUTNO CAT " "); READ();  % READ THE NUMBER AND THROW IT AWAY %

	DO NIL UNTIL TYO TYI() EQ OCTAL 45  
		(  ATOM(CHERRSET(READCH(),NIL))  PRINC CAR CH  NIL ) ;

	BUFFER(T); PRINTSTR(L); PRINC(M); PRINC(TAB); PRINTSTR(N);  TERPRI NIL; BUFFER(NIL);
	PRINC TERPRI EOF ;
	OUTC(NIL,T); INC(NIL,T); INC(CHANSAVE,NIL);
	END;

EXPR ERROR_FILE(A);

	BEGIN 	NEW FILCHAN, FILENAME,I;	TEN();
	CHANSAVEINC(NIL,NIL);
	FILCHAN  EVAL < 'INPUT, DIAFILEAREA, '(ERR.FIL) > ;
	INC(FILCHAN,NIL);
	FILENAMEAT("P" CAT (IREAD()));
	INC(CHANSAVE,NIL);
	EVAL < 'OUTPUT, DIAFILEAREA, '(ERR.FIL) > ;
	OUTC(T,NIL);
	PRINT(I+1);
	OUTC(NIL,T);

	OUTC( EVAL( <'OUTPUT, DIAFILEAREA, FILENAME CONS 'ERR > ), NIL);
	PRINT(A);
	OUTC(NIL, T);
	RETURN A;
        END;

 END.  _EOF_
